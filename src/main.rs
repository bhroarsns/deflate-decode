#[allow(unused_imports)]
use std::fs::File;
#[allow(unused_imports)]
use std::io::{BufReader, BufRead, BufWriter, Read, Write,};

const MAX_DIGIT: u8 = 8;
const U8_BITS: u8 = 8;
const U16_BITS: u8 = 16;
const MAX_REPEAT_LENGTH: u16 = 258;
const END_OF_BLOCK: u16 = 256;
const ADLER_MODULO: u64 = 65521;

struct BitStream {
    source: std::vec::IntoIter<u8>,
    remainder: Option<u8>,
    next_digit: u8,
}

impl BitStream {
    fn new(data: Vec<u8>) -> Self {
        Self {
            source: data.into_iter(),
            remainder: None,
            next_digit: MAX_DIGIT,
        }
    }

    fn skip_to_next_byte(&mut self) {
        if self.next_digit != MAX_DIGIT {
            self.remainder = None;
            self.next_digit = MAX_DIGIT;
        }
    }

    fn take_bytes(&mut self, len: usize) -> Vec<u8> {
        self.skip_to_next_byte();
        (0..len).flat_map(|_| self.source.next()).collect()
    }

    fn read_n_bits_as_lsb_first_u8(&mut self, n: u8) -> Option<u8> {
        (0..n)
            .map(|i| (i, self.next()))
            .take(U8_BITS as usize)
            .fold(Some(0_u8), |result, (i, x)| result.zip(x).map(|(r, x)| r + (x << i)))
    }

    fn read_n_bits_as_msb_first_u8(&mut self, n: u8) -> Option<u8> {
        (0..n)
            .map(|_| self.next())
            .take(U8_BITS as usize)
            .fold(Some(0_u8), |result, x| result.zip(x).map(|(r, x)| (r << 1) + x))
    }

    fn read_n_bits_as_lsb_first_u16(&mut self, n: u8) -> Option<u16> {
        (0..n)
            .map(|i| (i, self.next()))
            .take(U16_BITS as usize)
            .fold(Some(0_u16), |result, (i, x)| result.zip(x).map(|(r, x)| r + ((x as u16) << i)))
    }

    fn read_n_bits_as_msb_first_u16(&mut self, n: u8) -> Option<u16> {
        (0..n)
            .map(|_| self.next())
            .take(U16_BITS as usize)
            .fold(Some(0_u16), |result, x| result.zip(x).map(|(r, x)| (r << 1) + x as u16))
    }

    fn next(&mut self) -> Option<u8> {
        if self.next_digit == MAX_DIGIT {
            self.remainder = self.source.next();
            self.next_digit = 0;
        }
        let next_bit = self.remainder.map(|bit| bit & 1);
        self.remainder = self.remainder.map(|bit| bit >> 1);
        self.next_digit += 1;
        next_bit
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {

    let mut buf = BufReader::new(File::open("test.pdf")?);
    let mut data: Vec<u8> = Vec::new();
    buf.read_to_end(&mut data)?;

    for lit in data.into_iter() {
        if lit.is_ascii_graphic() | lit.is_ascii_whitespace() {
            print!("{}", lit as char);
        } else {
            print!("{}", lit.escape_ascii());
        }
    }

    // let data: Vec<u8> = vec![0x6b, 0x60, 0x18, 0x31, 0xc0, 0x01, 0x8d, 0xcf, 0x88, 0x4d, 0x51, 0xc3, 0x50, 0xf3, 0x55, 0x03, 0x00];
    // let data: Vec<u8> = vec![0x7d, 0x52, 0xb9, 0x52, 0xc4, 0x30, 0x0c, 0xed, 0xf3, 0x15, 0x2e, 0xd9, 0x62, 0x8d, 0x0e, 0x4b, 0x96, 0x67, 0x96, 0x14, 0x49, 0x08, 0x33, 0xd4, 0xe9, 0x18, 0x0a, 0x9a, 0xa5, 0xe2, 0xff, 0x5b, 0x44, 0xe2, 0x1d, 0x36, 0x21, 0xa4, 0xb2, 0x0e, 0xbf, 0x43, 0xb2, 0x21, 0x7c, 0x06, 0x08, 0x2f, 0x0d, 0xd4, 0xb3, 0x9b, 0x9a, 0xc7, 0x91, 0x2c, 0x94, 0x48, 0x48, 0x62, 0x61, 0xba, 0x36, 0xe8, 0x0d, 0x08, 0x18, 0x0c, 0x23, 0x26, 0x0a, 0x19, 0x35, 0x9a, 0x49, 0x98, 0xbe, 0xc2, 0xdb, 0x05, 0x58, 0x7a, 0xe0, 0x22, 0xc0, 0xd9, 0x80, 0x7b, 0x02, 0xee, 0x3c, 0xee, 0x53, 0xfb, 0x3e, 0xbd, 0x3a, 0x11, 0x8a, 0x13, 0x15, 0x25, 0x4d, 0xf7, 0x44, 0xc8, 0x1a, 0x13, 0xda, 0x86, 0x09, 0x68, 0xa8, 0x28, 0x86, 0x3d, 0x79, 0xd7, 0x8e, 0x02, 0x72, 0xa0, 0xdf, 0x11, 0x80, 0xf5, 0x76, 0xac, 0x6d, 0x16, 0x45, 0xff, 0x68, 0x8b, 0xb5, 0xe7, 0x94, 0x92, 0x47, 0x6a, 0x00, 0x3c, 0x02, 0x24, 0x27, 0x53, 0x6a, 0xcf, 0xcc, 0x7c, 0xd9, 0x66, 0xd8, 0x7b, 0x65, 0xb8, 0x65, 0xec, 0xbd, 0x9c, 0x6a, 0xb5, 0x73, 0x2e, 0x8f, 0x93, 0x2d, 0x75, 0x1a, 0xd6, 0x18, 0xaf, 0x8c, 0xd5, 0x1f, 0xc1, 0x9e, 0x3f, 0x06, 0x8e, 0x82, 0x79, 0xeb, 0x4f, 0xcb, 0xc6, 0x95, 0xad, 0x5c, 0xcd, 0x19, 0xb1, 0x47, 0xf4, 0x33, 0x0c, 0x2e, 0x06, 0x5c, 0xaa, 0xb6, 0x38, 0xd7, 0xea, 0xd0, 0xce, 0x37, 0xb4, 0x1c, 0x2e, 0x89, 0x8d, 0xa2, 0x69, 0xd9, 0x59, 0x52, 0x7d, 0x20, 0xde, 0x43, 0x91, 0x49, 0xcc, 0x1c, 0xd4, 0x37, 0x5c, 0xca, 0x8c, 0x79, 0xf8, 0x38, 0x2d, 0x00, 0xc5, 0x5d, 0x40, 0xe1, 0x98, 0x75, 0x8d, 0x78, 0x3a, 0x1d, 0x49, 0x30, 0xa4, 0x48, 0xb9, 0xec, 0x68, 0xdc, 0xfe, 0xef, 0x7f, 0x23, 0x51, 0x11, 0xff, 0xbd, 0x39, 0xa8, 0xba, 0xe4, 0xef, 0x44, 0xd4, 0xde, 0x83, 0x9f, 0xa7, 0xe6, 0x1b];
    // let data: Vec<u8> = vec![0x8d, 0x54, 0x7b, 0x50, 0x54, 0x55, 0x18, 0x3f, 0x97, 0x65, 0xf7, 0xa2, 0x2c, 0x0b, 0xed, 0x05, 0x52, 0x56, 0xef, 0x3d, 0x5a, 0x3c, 0x1c, 0x65, 0x77, 0x53, 0x27, 0x7b, 0x39, 0x12, 0x06, 0x26, 0x89, 0x89, 0xac, 0x8a, 0xb4, 0x35, 0x3c, 0xf6, 0xc2, 0x6e, 0x0b, 0xbb, 0xb0, 0x77, 0x37, 0xc0, 0x7c, 0x66, 0x18, 0x7a, 0x10, 0x01, 0x95, 0xcc, 0x07, 0xe0, 0x9b, 0x40, 0x41, 0x20, 0x18, 0xbd, 0x58, 0xa9, 0xe3, 0x64, 0x64, 0x7f, 0x98, 0x32, 0xea, 0xd4, 0xf8, 0x47, 0x66, 0x93, 0x35, 0x34, 0x31, 0xa4, 0x7d, 0xd7, 0x39, 0xce, 0xd4, 0x5d, 0x6c, 0x52, 0xa7, 0xfe, 0xe8, 0x9c, 0x99, 0xf3, 0xfc, 0xce, 0xef, 0xf1, 0x9d, 0x99, 0x8f, 0x41, 0xa1, 0xa1, 0x88, 0x61, 0x98, 0xd8, 0xe5, 0xaf, 0xbc, 0x9c, 0x9b, 0xbe, 0x74, 0xfa, 0xa2, 0xcc, 0xa5, 0xde, 0xd2, 0x7c, 0xcf, 0x33, 0xd6, 0xe4, 0x54, 0x6f, 0x89, 0x23, 0x78, 0x93, 0xae, 0x60, 0x65, 0x0a, 0xd1, 0xf3, 0xca, 0x24, 0xa4, 0x4c, 0x66, 0x14, 0x3e, 0x44, 0x11, 0x34, 0x4a, 0x74, 0x28, 0x4d, 0xd0, 0x6b, 0x2e, 0xe8, 0x43, 0xef, 0xaf, 0xa2, 0x03, 0x93, 0x74, 0x0b, 0x26, 0x85, 0x96, 0x6a, 0x27, 0x23, 0xc4, 0x6c, 0x89, 0x0c, 0x8e, 0x47, 0x9f, 0xb8, 0xab, 0x9f, 0xaa, 0x2e, 0xb4, 0x1b, 0xf4, 0x4f, 0x07, 0xf7, 0x2d, 0xfa, 0x78, 0xc4, 0x86, 0x20, 0x06, 0xc5, 0x22, 0x13, 0xfa, 0x05, 0x29, 0x2a, 0xaa, 0x8e, 0x31, 0xfc, 0x27, 0xe3, 0x4c, 0xb3, 0xd5, 0x3a, 0x7b, 0xbe, 0xb7, 0xac, 0xca, 0xe7, 0x2a, 0x76, 0xfa, 0xf1, 0x4c, 0xab, 0x75, 0xd6, 0x8c, 0xe0, 0xf8, 0x3c, 0x4e, 0x35, 0xe3, 0x8c, 0xfc, 0x42, 0xb7, 0xb7, 0x42, 0x72, 0xbb, 0x70, 0xbe, 0xc7, 0x81, 0x33, 0xcc, 0x38, 0xd3, 0x8c, 0x17, 0x7b, 0x2b, 0xd4, 0x53, 0x17, 0x4e, 0xf2, 0x7a, 0x70, 0x81, 0xe8, 0xcc, 0x2f, 0x29, 0xc2, 0xde, 0x22, 0x6c, 0x13, 0x73, 0x70, 0x40, 0x12, 0x7d, 0x12, 0x2e, 0xf6, 0x79, 0x03, 0x65, 0xd2, 0x34, 0x33, 0xb6, 0x39, 0x5d, 0x12, 0xae, 0xf0, 0xfa, 0xdc, 0x58, 0x9d, 0x7d, 0x62, 0x89, 0x98, 0x2f, 0x89, 0x0e, 0x1c, 0xf0, 0x38, 0x44, 0x1f, 0xf6, 0x3b, 0x45, 0xbc, 0x60, 0x59, 0xb6, 0x0d, 0xa7, 0x7b, 0x3d, 0x7e, 0xbc, 0xc8, 0x55, 0x28, 0x7a, 0x24, 0x11, 0x27, 0x27, 0x63, 0x2c, 0x89, 0x22, 0x76, 0xfa, 0xfd, 0x65, 0x2f, 0x58, 0x2c, 0xfe, 0x40, 0xb1, 0xd9, 0xeb, 0x2b, 0xb6, 0x14, 0xa9, 0x31, 0x92, 0xa5, 0xe4, 0x41, 0x90, 0x64, 0x09, 0xbe, 0x4b, 0x4e, 0x7f, 0x7d, 0xb1, 0x2d, 0x79, 0xd1, 0xc2, 0xf9, 0x69, 0x8b, 0xb3, 0xd3, 0xcc, 0xfe, 0x4a, 0x3f, 0x2e, 0xf2, 0xfa, 0xb0, 0x43, 0xf4, 0xe7, 0xbb, 0x4a, 0x24, 0xf3, 0xe3, 0x0e, 0xff, 0xd9, 0xbd, 0xec, 0xf0, 0x16, 0x88, 0x0b, 0x1d, 0xa2, 0xc7, 0xef, 0xf2, 0x57, 0x21, 0xb5, 0x3d, 0x85, 0x2c, 0x68, 0x0e, 0x9a, 0x87, 0x52, 0xd1, 0xab, 0x28, 0x13, 0x65, 0xa1, 0x02, 0xe4, 0xd2, 0xa8, 0x49, 0x53, 0x5b, 0x38, 0x0a, 0x0f, 0xa6, 0x2f, 0x14, 0xad, 0x42, 0xbf, 0x31, 0xaf, 0x31, 0xed, 0xcc, 0x1f, 0x21, 0xf1, 0x21, 0xeb, 0x43, 0xae, 0x69, 0x02, 0x9a, 0x33, 0x70, 0xcc, 0x70, 0x8f, 0xab, 0xee, 0x52, 0xa2, 0xbb, 0x20, 0xeb, 0x9c, 0xf1, 0x2e, 0xe8, 0x08, 0x44, 0x43, 0x14, 0x44, 0x73, 0x65, 0xca, 0x30, 0x48, 0x31, 0x30, 0x31, 0xf9, 0x67, 0x1a, 0x9f, 0xba, 0xd2, 0x53, 0x21, 0xf1, 0x70, 0x8a, 0xa5, 0x69, 0x1b, 0xb5, 0x76, 0x76, 0xb0, 0x91, 0x38, 0x84, 0xfb, 0xc3, 0x32, 0xbb, 0xa7, 0x79, 0xef, 0xbe, 0x3d, 0xcd, 0x61, 0xdc, 0xd7, 0x1b, 0xb7, 0x9f, 0x5e, 0x76, 0xcb, 0x04, 0xd3, 0x46, 0x7f, 0x04, 0x41, 0xa0, 0xd1, 0xb1, 0x76, 0x62, 0x2b, 0x77, 0xf0, 0x05, 0x9e, 0x37, 0xd7, 0xbb, 0x4d, 0x69, 0x8e, 0xb3, 0xbb, 0x37, 0x08, 0xb0, 0x8d, 0xed, 0x3c, 0x32, 0xd0, 0x76, 0xce, 0x04, 0x06, 0x42, 0x23, 0xd2, 0x84, 0x31, 0xd6, 0x52, 0x59, 0xd1, 0xa8, 0xbc, 0xb2, 0xfd, 0x9c, 0xb1, 0x5b, 0xa5, 0xad, 0x07, 0x1d, 0x97, 0xa1, 0xfc, 0x1a, 0x2b, 0xb3, 0x99, 0xef, 0x93, 0x1e, 0x41, 0xb9, 0xc3, 0x72, 0xfd, 0x8f, 0x30, 0xd2, 0x15, 0x6c, 0xcf, 0xca, 0x15, 0x0d, 0x6f, 0x9b, 0x68, 0xc2, 0xd4, 0x59, 0x74, 0x0a, 0x9d, 0xf0, 0xd3, 0x0c, 0x48, 0xfa, 0x72, 0xe0, 0xe0, 0xa1, 0x76, 0x21, 0x97, 0xe5, 0x52, 0x80, 0x09, 0xe5, 0x8e, 0x54, 0xad, 0x2d, 0xb0, 0xcd, 0x33, 0x51, 0x03, 0x81, 0x88, 0x6f, 0x06, 0xc8, 0xd9, 0xc3, 0x3d, 0x42, 0x5f, 0x9b, 0xbc, 0xb3, 0xdd, 0x74, 0xbe, 0xd7, 0xed, 0xd9, 0x2f, 0x18, 0xe0, 0x77, 0x22, 0xc3, 0xa8, 0x0c, 0x65, 0x5d, 0x0c, 0x8c, 0x03, 0x74, 0x0b, 0x22, 0x35, 0xca, 0x42, 0xe5, 0x5e, 0x4c, 0x5f, 0xf1, 0xc9, 0xb9, 0xd3, 0x28, 0xca, 0xa7, 0x5a, 0x3e, 0x21, 0xc5, 0x7e, 0x95, 0x8e, 0xa6, 0xdb, 0x59, 0x30, 0xd6, 0x69, 0xbb, 0x2f, 0x92, 0x9a, 0x2e, 0x41, 0x9e, 0x0d, 0xa3, 0xc0, 0xca, 0x34, 0x62, 0x84, 0x85, 0x90, 0x6b, 0x3b, 0x0e, 0xd5, 0xd7, 0x93, 0xcd, 0x8d, 0xfc, 0xea, 0xf5, 0x1b, 0x2b, 0x2b, 0xe3, 0xf2, 0x3a, 0x2b, 0x0f, 0x7f, 0xdc, 0xd1, 0xfa, 0x09, 0xaf, 0x1a, 0x22, 0x0f, 0xed, 0x80, 0x4e, 0xed, 0x79, 0xaa, 0x9f, 0x21, 0x85, 0xc6, 0xca, 0xe9, 0xf0, 0x21, 0x7b, 0x67, 0x59, 0x4f, 0xe2, 0xf4, 0x9c, 0x2c, 0x31, 0xc0, 0x6f, 0x81, 0xdb, 0x3a, 0x6e, 0xf8, 0xd1, 0x54, 0x7e, 0xfa, 0x80, 0x0e, 0x8c, 0x35, 0x5a, 0x35, 0x56, 0x64, 0x81, 0xf9, 0xfe, 0xf4, 0x57, 0xc7, 0x5b, 0xdf, 0x99, 0xc7, 0xd3, 0x03, 0x7f, 0x2b, 0x31, 0xc0, 0x15, 0x55, 0xfa, 0x88, 0x8a, 0xfd, 0x2d, 0x58, 0x8d, 0x37, 0xc0, 0x4a, 0x0d, 0x80, 0xb8, 0x43, 0xd0, 0x13, 0x2b, 0x67, 0x2a, 0x89, 0x2c, 0x77, 0x9e, 0xa6, 0x06, 0xf1, 0xbe, 0x18, 0x4b, 0xd4, 0x60, 0xf0, 0x91, 0xa1, 0x4e, 0xcb, 0x4d, 0xb8, 0xa4, 0x8c, 0xc4, 0xf4, 0x3b, 0x3b, 0xf3, 0xf2, 0x9c, 0xce, 0xbc, 0xbc, 0x4e, 0x67, 0x7f, 0x7f, 0x67, 0x67, 0x3f, 0x3f, 0x86, 0xa5, 0xdc, 0x1a, 0xd3, 0x19, 0xa6, 0xa2, 0x9c, 0x80, 0x53, 0xaa, 0xc6, 0x7b, 0x26, 0x96, 0xbb, 0xf4, 0x2f, 0x55, 0x91, 0x2a, 0x75, 0xd0, 0xd9, 0x18, 0xf5, 0x43, 0x5b, 0x6d, 0x8f, 0xd9, 0x5a, 0xbe, 0x34, 0xa7, 0x9c, 0x07, 0xc4, 0x72, 0xd7, 0x69, 0xca, 0xc3, 0xef, 0x1a, 0xfc, 0x1f, 0xae, 0x94, 0x2b, 0xd5, 0xbd, 0x0a, 0xd7, 0xc5, 0x74, 0xa8, 0xdf, 0xdf, 0x08, 0xd1, 0x1a, 0xa5, 0x07, 0x3c, 0x31, 0x10, 0x67, 0x19, 0xa1, 0x73, 0xe8, 0x73, 0xd6, 0x78, 0x3a, 0x91, 0x46, 0xfd, 0x90, 0x08, 0x2f, 0xc2, 0x4b, 0x37, 0x47, 0x20, 0x92, 0xa7, 0xd1, 0x4d, 0x31, 0xb3, 0x09, 0x45, 0x94, 0xa3, 0x1c, 0x01, 0x74, 0xf3, 0x24, 0xf9, 0x6c, 0xef, 0x71, 0xfe, 0x44, 0x73, 0x5f, 0xeb, 0x69, 0x53, 0x5f, 0xdf, 0xbb, 0xce, 0xfd, 0x42, 0xab, 0x8b, 0xd8, 0xde, 0x88, 0x33, 0x28, 0xb9, 0xd5, 0x1d, 0xee, 0x2e, 0xc5, 0xd4, 0x61, 0xec, 0xbe, 0x0c, 0xeb, 0x2e, 0x73, 0x95, 0xca, 0x2c, 0xc0, 0x31, 0xfd, 0x15, 0x9d, 0xce, 0xa3, 0xbc, 0xa3, 0xcd, 0xdd, 0x30, 0x77, 0x57, 0x58, 0x51, 0x63, 0x46, 0x93, 0x1c, 0x37, 0x78, 0x9b, 0x34, 0x5f, 0xed, 0xf6, 0xd8, 0xea, 0xf9, 0xd5, 0xb5, 0xb5, 0x9b, 0x5a, 0x4d, 0x07, 0x49, 0xfd, 0x01, 0xe1, 0x3b, 0xb6, 0x99, 0xec, 0xa8, 0xfa, 0x60, 0x33, 0xa9, 0x74, 0xf0, 0xbb, 0xca, 0x9d, 0x0d, 0x85, 0xa6, 0x52, 0x6a, 0x26, 0xf4, 0xc9, 0xc2, 0x96, 0xb2, 0x96, 0x55, 0x42, 0xaf, 0xb3, 0xbb, 0xfa, 0xfa, 0x9a, 0xb0, 0xae, 0xea, 0xab, 0x6b, 0x97, 0xc4, 0xa5, 0x58, 0x48, 0x60, 0x4a, 0xf9, 0x50, 0xff, 0x3a, 0xfe, 0xa3, 0x4d, 0x9b, 0xc8, 0x1a, 0x93, 0x44, 0xaa, 0xfd, 0x02, 0x65, 0xd8, 0x4a, 0xf2, 0xde, 0xbe, 0xc6, 0xad, 0x64, 0x77, 0x2b, 0xcf, 0xd5, 0x1c, 0xde, 0xab, 0x75, 0x9f, 0xfa, 0x9c, 0xb4, 0x98, 0xda, 0xc1, 0x4c, 0x20, 0x41, 0x30, 0x28, 0xd9, 0xd5, 0xbd, 0xf0, 0xa7, 0x0c, 0xd9, 0x15, 0xc6, 0x51, 0xd0, 0xd9, 0x65, 0x18, 0x2f, 0x73, 0xc3, 0x8a, 0x11, 0xa2, 0x62, 0xce, 0xd8, 0x73, 0xd8, 0x05, 0x6e, 0xc9, 0x9b, 0x45, 0x2e, 0x1e, 0xe0, 0xa1, 0x0d, 0x12, 0x64, 0x9a, 0x00, 0xd9, 0x76, 0x76, 0x4b, 0x62, 0x6e, 0x52, 0x52, 0x4d, 0x58, 0x31, 0xcb, 0x0d, 0xdd, 0xa0, 0x47, 0x74, 0xf8, 0x66, 0xe0, 0xf2, 0xb5, 0x93, 0xe7, 0x87, 0x78, 0x43, 0xb0, 0xc4, 0x46, 0x29, 0x26, 0x7d, 0x82, 0x5a, 0x28, 0xd1, 0xb3, 0xc1, 0xa2, 0xb9, 0xd3, 0xb8, 0xbe, 0x49, 0x59, 0xb2, 0x03, 0xde, 0x6a, 0xdd, 0xd9, 0xa4, 0xe3, 0x33, 0x6c, 0x25, 0x16, 0xfd, 0x38, 0xa2, 0x0f, 0x97, 0xc7, 0x83, 0x2e, 0xfc, 0x58, 0x5d, 0x5d, 0x6d, 0xed, 0xd6, 0x6d, 0xb5, 0x8d, 0x8d, 0xc7, 0x2f, 0xe8, 0xf5, 0x72, 0x43, 0xdf, 0xae, 0x86, 0xa6, 0xba, 0xed, 0xdb, 0xb6, 0x36, 0xd5, 0xe9, 0x23, 0xfe, 0x02];
    // let data: Vec<u8> = vec![0x78, 0xda, 0x7d, 0x92, 0x5d, 0x6b, 0xc2, 0x30, 0x14, 0x86, 0xef, 0xf3, 0x2b, 0xce, 0x2e, 0x04, 0xbd, 0xe8, 0x9a, 0x56, 0xe7, 0x9c, 0x48, 0xc1, 0xaf, 0x42, 0x61, 0x53, 0x51, 0x19, 0x63, 0x77, 0x35, 0x39, 0xba, 0x80, 0x4d, 0x4a, 0xda, 0x5e, 0xf8, 0xef, 0x97, 0x0f, 0xab, 0x30, 0x64, 0x85, 0x96, 0x3e, 0x7d, 0xcf, 0x39, 0x7d, 0xf3, 0x26, 0x9d, 0xa7, 0xcd, 0x2e, 0x98, 0x72, 0x75, 0xc0, 0xa0, 0xff, 0x4c, 0x61, 0x8b, 0x95, 0x6a, 0x34, 0xc3, 0x60, 0xfe, 0x91, 0x97, 0xa4, 0xd3, 0x59, 0x28, 0xd6, 0x14, 0x28, 0xeb, 0x15, 0x22, 0x47, 0xde, 0xaa, 0xd5, 0x18, 0x36, 0x5a, 0xb1, 0x1d, 0xd6, 0xd0, 0x9d, 0x67, 0x8b, 0x4c, 0x8a, 0xba, 0x67, 0x8a, 0x33, 0xc9, 0xce, 0x0d, 0xc7, 0xb6, 0xea, 0x71, 0xd1, 0x0c, 0x4f, 0x42, 0xde, 0x4b, 0xec, 0x7f, 0xa0, 0xbb, 0xc7, 0xaf, 0xe0, 0x73, 0x31, 0xfd, 0x4e, 0xb7, 0xc1, 0xfb, 0xc7, 0x56, 0x15, 0xb9, 0x8c, 0x68, 0x30, 0x53, 0x67, 0x1e, 0x50, 0xdb, 0xb3, 0x17, 0xf5, 0xd9, 0xd4, 0xfe, 0x57, 0x06, 0x46, 0x83, 0x87, 0x1a, 0xb8, 0x11, 0x9f, 0xa8, 0x2b, 0xa1, 0xe4, 0x18, 0xa2, 0x67, 0x4a, 0xa9, 0xf9, 0xb0, 0x94, 0x7c, 0xae, 0x0a, 0xbb, 0xb6, 0x8a, 0x84, 0x57, 0x7f, 0x10, 0xb6, 0x8e, 0x8f, 0x42, 0x72, 0x7d, 0x35, 0x09, 0x07, 0x6b, 0x99, 0x44, 0x31, 0x70, 0xc1, 0xea, 0x2b, 0xb9, 0x27, 0x2b, 0x4c, 0x48, 0xb6, 0x79, 0x77, 0xa9, 0x6a, 0x2c, 0x32, 0x79, 0x54, 0x64, 0x32, 0x81, 0x70, 0x6b, 0xc4, 0xaa, 0xd6, 0x17, 0xe7, 0xb8, 0x47, 0xc2, 0xb5, 0xe6, 0xa8, 0x85, 0x3c, 0x41, 0xf7, 0xa1, 0x43, 0x53, 0xb1, 0x6b, 0xca, 0xf2, 0x8c, 0xd6, 0x0d, 0x50, 0x92, 0x24, 0xc0, 0xf1, 0x68, 0x06, 0x9b, 0x6c, 0x56, 0x79, 0x81, 0x10, 0xda, 0x85, 0x67, 0xdc, 0xa8, 0xa2, 0xbe, 0x3c, 0x4e, 0xe0, 0xde, 0xb1, 0xbf, 0x94, 0x08, 0xb1, 0xe3, 0xc8, 0x9b, 0x65, 0x8a, 0x63, 0x55, 0xe6, 0x0c, 0x75, 0x2e, 0x4f, 0x48, 0x26, 0x26, 0x00, 0x9a, 0xc0, 0x24, 0x35, 0x57, 0x42, 0x50, 0xf2, 0x3f, 0x3a, 0xf5, 0x5d, 0x87, 0xa3, 0x47, 0x53, 0xd0, 0xbe, 0x46, 0x37, 0x89, 0xfd, 0xe4, 0xda, 0x0e, 0x8a, 0xfb, 0x66, 0x10, 0xa5, 0xc3, 0x38, 0x71, 0x94, 0x7a, 0x1a, 0x38, 0xea, 0xbf, 0x7a, 0x1a, 0x7a, 0xba, 0x6a, 0x23, 0x47, 0x83, 0xd8, 0xd3, 0x9b, 0xa7, 0x91, 0xa7, 0xb9, 0xa7, 0x85, 0xa7, 0xa5, 0xa3, 0x97, 0xc8, 0x53, 0xea, 0x68, 0xe8, 0xfb, 0x5e, 0xfb, 0x9e, 0xde, 0x3c, 0x0d, 0x12, 0xef, 0xd2, 0xb9, 0xb2, 0x0b, 0xb2, 0xfb, 0x72, 0x4b, 0x8f, 0x35, 0x5a, 0x9b, 0xe8, 0xdc, 0xe6, 0xb9, 0x84, 0x6c, 0x36, 0x42, 0xe2, 0x6d, 0x7f, 0x4b, 0x55, 0xda, 0x2e, 0x77, 0xbb, 0x83, 0xd1, 0x1e, 0x4f, 0x4b, 0xeb, 0x94, 0xfc, 0x02, 0xa2, 0x49, 0xf2, 0x18];
    // let verbose = false;
    

    Ok(())
}

fn decode_zlib(data: Vec<u8>, verbose:bool) -> Result<(), Box<dyn std::error::Error>> {
    let mut datastream = BitStream::new(data);

    let cmf = datastream.read_n_bits_as_lsb_first_u16(8).expect("");
    let flg = datastream.read_n_bits_as_lsb_first_u16(8).expect("");

    if (((cmf << 8) + flg) % 31) != 0 {
        panic!("[E] ZLIB header not recognized.");
    } else {
        println!("[I] ZLIB header detected.");
    }

    let cm = cmf % 0b10000;
    let cinfo = cmf >> 4;
    if cm != 8 {
        panic!("[E] I don't know how to treat with the zlib data compressed by the method other than \"deflate\".");
    }
    println!("[I] LZ77 window size is specified as 2^{}", cinfo + 8);

    let flg = flg >> 5;
    if flg % 0b10 == 1 {
        panic!("[E] There is a preset dictionary, which I don't know how to treat with.");
    }
    match flg >> 1 {
        0 => println!("[I] FLEVEL 0(compressor used fastest algorithm)"),
        1 => println!("[I] FLEVEL 1(compressor used fast algorithm)"),
        2 => println!("[I] FLEVEL 2(compressor used default algorithm)"),
        3 => println!("[I] FLEVEL 3(compressor used maximum compression, slowest algorithm)"),
        _ => panic!("[E] FLEVEL not recognized"),
    };
    
    let mut adler_checksum_a = 1;
    let mut adler_checksum_b = 0;

    let mut output: Vec<u8> = Vec::new();
    let mut bfinal = false;

    while !bfinal {
        if datastream.next().expect("[E] Reached the end of the stream whlie reading data block header.") == 1 {
            println!("[I] This is the last block.");
            bfinal = true;
        }

        let btype = datastream.read_n_bits_as_lsb_first_u8(2).expect("[E] Reached the end of the stream whlie reading data block header.");
        if btype == 0 {
            println!("[I] Compression type 00(no compression) detected.");
            datastream.skip_to_next_byte();
            let len = datastream.read_n_bits_as_lsb_first_u16(16).expect("[E] Reached the end of the stream while reading LEN for an uncompressed data block.");
            let nlen = datastream.read_n_bits_as_lsb_first_u16(16).expect("[E] Reached the end of the stream while reading NLEN for an uncompressed data block.");
            if nlen == !len {
                output = datastream.take_bytes(len as usize);
            } else {
                panic!("[E] Illegal NLEN. NLEN should be ones' complement of LEN.\n[E] LEN is {:0x} so NLEN should be {:0x}, not {:0x}.", len, !len, nlen)
            }
        } else if btype > 2 {
            panic!("[E] Illegal compression type detected.")
        } else {
            let (literal_index, distance_index) = if btype == 1 {
                println!("[I] Compression type 01(compressed with fixed Huffman codes) detected.");

                (
                    vec![(256_u16, 7_u8, 0_u16, 24_u16), (0, 1, 48, 192), (280, 0, 192, 200), (144, 1, 400, 512)],
                    vec![(0_u8, 5_u8, 0_u8, 32_u8)]
                )
            } else {
                println!("[I] Compression type 10(compressed with dynamic Huffman codes) detected.");

                let nlit = 257 + datastream.read_n_bits_as_lsb_first_u16(5).expect("[E] Reached the end of the stream while reading HLIST.");
                let ndist = 1 + datastream.read_n_bits_as_lsb_first_u16(5).expect("[E] Reached the end of the stream while reading HDIST.");
                let nclen = 4 + datastream.read_n_bits_as_lsb_first_u16(4).expect("[E] Reached the end of the stream while reading HCLEN.");

                let code_length_index: Vec<(u8, u8, u8)> = {
                    let mut code_length_dict: Vec<(u8, u8)> = [16_u8, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15].into_iter().take(nclen as usize).map(|length| {
                        (datastream.read_n_bits_as_lsb_first_u8(3).expect("[E] Reached the end of the stream while reading code lengths for code length codes."), length)
                    }).filter(|(code_len, _)| code_len != &0).collect();
                    code_length_dict.sort_by_key(|(_, len)| *len);
                    code_length_dict.sort_by_key(|(code_len, _)| *code_len);
                    code_length_dict.into_iter().scan((0, 0), |(cur_code, cur_len), (len, code_len)| {
                        let diff = len - *cur_len;
                        if cur_len != &len {
                            *cur_code <<= diff
                        };
                        let code = *cur_code;
                        *cur_len = len;
                        *cur_code += 1;
                        Some((code_len, diff, code))
                    }).collect()
                };

                if verbose {
                    println!("[I] Huffman codes for code length codes are calculated as follows:");
                    let mut cur_length = 0;
                    for (start, shift, first_code) in &code_length_index {
                        cur_length += *shift as usize;
                        println!("[I] Code length code {:2} -> Huffman code {:0cur_length$b}", start, first_code);
                    }
                }

                let mut code_length_count = 0;
                let mut literal_dict: Vec<(u8, u16, u16)> = Vec::new();
                let mut distance_dict: Vec<(u8, u8, u8)> = Vec::new();
                let mut group_start = 0;
                let mut cur_length = 0;
                let mut cur_repeat = 0;

                let mut is_reading_literal_dict = true;

                loop {
                    let code_length_code = {
                        let mut cur_huffman_code: u8 = 0;
                        let mut code_length_iter = code_length_index.iter();
                        loop {
                            match code_length_iter.next() {
                                Some((code_len, shift, code)) => {
                                    cur_huffman_code <<= shift;
                                    cur_huffman_code += datastream.read_n_bits_as_msb_first_u8(*shift).expect("[E] Reached the end of the stream while reading Huffman code.");
                                    if cur_huffman_code == *code {
                                        break *code_len;
                                    } else if cur_huffman_code > *code {
                                        continue;
                                    } else {
                                        panic!("[E] Failed to decode a Huffman code for code length code.");
                                    }
                                },
                                None => {
                                    panic!("[E] Failed to decode a Huffman code for code length code.");
                                }
                            }
                        }
                    };

                    let (length_changed, repeat, new_length) = if code_length_code < 16 {
                        ((cur_length != code_length_code), 1, code_length_code)
                    } else if code_length_code == 16 {
                        (false, 3 + datastream.read_n_bits_as_lsb_first_u16(2).expect("[E] Reached the end of the stream while reading an extra code for a code length code."), cur_length)
                    } else {
                        (
                            (cur_length != 0),
                            if code_length_code == 17 {
                                3 + datastream.read_n_bits_as_lsb_first_u16(3).expect("[E] Reached the end of the stream while reading an extra code for a code length code.")
                            } else if code_length_code == 18 {
                                11 + datastream.read_n_bits_as_lsb_first_u16(7).expect("[E] Reached the end of the stream while reading an extra code for a code length code.")
                            } else {
                                panic!("[E] Illegal code length code.")
                            },
                            0,
                        )
                    };

                    if length_changed {
                        if cur_length != 0 {
                            if is_reading_literal_dict {
                                literal_dict.push((cur_length, group_start, cur_repeat));
                            } else {
                                distance_dict.push((cur_length, group_start as u8, cur_repeat as u8));
                            }
                        }
                        cur_length = new_length;
                        group_start = code_length_count;
                        cur_repeat = repeat;
                    } else {
                        cur_repeat += repeat;
                    }
                    code_length_count += repeat;
                    
                    if is_reading_literal_dict {
                        if code_length_count < nlit {
                            continue;
                        } else {
                            let overflow = code_length_count - nlit;
                            if cur_length != 0 {
                                literal_dict.push((cur_length, group_start, cur_repeat - overflow));
                            }
                            if overflow == 0 {
                                cur_length = 0;
                            }
                            group_start = 0;
                            cur_repeat = overflow;
                            code_length_count = overflow;
                            is_reading_literal_dict = false;
                            continue;
                        }
                    } else {
                        if code_length_count < ndist {
                            continue;
                        } else if code_length_count == ndist {
                            if cur_length != 0 {
                                distance_dict.push((cur_length, group_start as u8, cur_repeat as u8));
                            }
                            break;
                        } else {
                            panic!("[E] Too many code lengths. The number of code lengths is specified as {}, but {} code lengths found.", nlit + ndist, code_length_count + nlit);
                        }
                    }
                }

                literal_dict.sort_by_key(|(a, _, _)| *a);
                distance_dict.sort_by_key(|(a, _, _)| *a);
                (
                    literal_dict.into_iter().scan((0, 0), |(cur_code, cur_len), (len, start, num_items)| {
                        let diff = len - *cur_len;
                        if cur_len != &len {
                            *cur_code <<= diff
                        };
                        let code = *cur_code;
                        *cur_len = len;
                        *cur_code += num_items;
                        Some((start, diff, code, code + num_items))
                    }).collect(),
                    distance_dict.into_iter().scan((0, 0), |(cur_code, cur_len), (len, start, num_items)| {
                        let diff = len - *cur_len;
                        if cur_len != &len {
                            *cur_code <<= diff
                        };
                        let code = *cur_code;
                        *cur_len = len;
                        *cur_code += num_items;
                        Some((start, diff, code, code + num_items))
                    }).collect(),
                )
            };

            if verbose {
                println!("[I] Huffman codes for Literal/Length codes are calculated as follows:");
                let mut cur_length = 0;
                for (start, shift, first_code, last_code) in &literal_index {
                    cur_length += *shift as usize;
                    if *first_code != (last_code - 1) {
                        println!("[I] Literal/Length codes {:3}-{:3} -> Huffman codes {:0cur_length$b}-{:0cur_length$b}", start, start + (last_code - first_code) - 1, first_code, last_code - 1);
                    } else {
                        println!("[I] Literal/Length code  {:3}     -> Huffman code  {:0cur_length$b}", start, first_code);
                    }
                    
                }
                println!("[I] Huffman codes for Distance codes are calculated as follows:");
                let mut cur_length = 0;
                for (start, shift, first_code, last_code) in &distance_index {
                    cur_length += *shift as usize;
                    if *first_code != (last_code - 1) {
                        println!("[I] Distance codes {:2}-{:2} -> Huffman codes {:0cur_length$b}-{:0cur_length$b}", start, start + (last_code - first_code) - 1, first_code, last_code - 1);
                    } else {
                        println!("[I] Distance code  {:2}    -> Huffman code  {:0cur_length$b}", start, first_code);
                    }
                    
                }
            }

            let mut output_count = 0_usize;
            loop {
                let literal_code = {
                    let mut cur_huffman_code: u16 = 0;
                    let mut literal_iter = literal_index.iter();
                    loop {
                        match literal_iter.next() {
                            Some((start, shift, first_code, last_code)) => {
                                cur_huffman_code <<= shift;
                                cur_huffman_code += datastream.read_n_bits_as_msb_first_u16(*shift).expect("[E] Reached the end of the stream while reading Huffman code.");
                                if cur_huffman_code < *first_code {
                                    panic!("[E] Failed to decode a Huffman code for Literal/Length code.");
                                } else if cur_huffman_code < *last_code {
                                    break start + (cur_huffman_code - first_code);
                                } else{
                                    continue;
                                }
                            },
                            None => {
                                panic!("[E] Failed to decode a Huffman code for Literal/Length code.");
                            }
                        }
                    }
                };
                if literal_code == END_OF_BLOCK {
                    break;
                } else if literal_code < END_OF_BLOCK {
                    output.push(literal_code as u8);
                    adler_checksum_a += literal_code as u64;
                    if (std::u64::MAX - adler_checksum_b) > adler_checksum_a {
                        adler_checksum_b += adler_checksum_a;
                    } else {
                        adler_checksum_a %= ADLER_MODULO;
                        adler_checksum_b %= ADLER_MODULO;
                        adler_checksum_b += adler_checksum_a as u64;
                    }
                    output_count += 1;
                } else {
                    let length_code = literal_code - END_OF_BLOCK - 1;
                    let length = {
                        let quotient = length_code / 4;
                        if quotient < 2 {
                            3 + length_code
                        } else if quotient < 7 {
                            let extra_len = quotient - 1;
                            let extra = datastream.read_n_bits_as_lsb_first_u16(extra_len as u8).expect("[E] Reached the end of the stream while reading extra code.");
                            3 + ((4 + length_code % 4) << extra_len) + extra
                        } else if quotient == 8 {
                            MAX_REPEAT_LENGTH
                        } else {
                            panic!("[E] Illegal length code: {}", literal_code)
                        }
                    };
                    let distance_code = {
                        let mut cur_huffman_code: u8 = 0;
                        let mut distance_iter = distance_index.iter();
                        loop {
                            match distance_iter.next() {
                                Some((start, shift, first_code, last_code)) => {
                                    cur_huffman_code <<= shift;
                                    cur_huffman_code += datastream.read_n_bits_as_msb_first_u8(*shift).expect("[E] Reached the end of the stream while reading Huffman code.");
                                    if cur_huffman_code < *first_code {
                                        panic!("[E] Illegal Huffman code.");
                                    } else if cur_huffman_code < *last_code {
                                        break start + (cur_huffman_code - first_code);
                                    } else{
                                        continue;
                                    }
                                },
                                None => {
                                    panic!("[E] Illegal Huffman code.");
                                }
                            }
                        }
                    };
                    let distance = {
                        let quotient = distance_code as u16 / 2;
                        if quotient < 2 {
                            1 + distance_code as u16
                        } else if quotient < 15 {
                            let extra_len = quotient - 1;
                            let extra = datastream.read_n_bits_as_lsb_first_u16(extra_len as u8).expect("[E] Reached the end of the stream while reading extra code.");
                            1 + ((2 + distance_code as u16 % 2) << extra_len) + extra
                        } else {
                            panic!("[E] Illegal distance code: {}", distance_code)
                        }
                    };
                    if (distance as usize) < output_count {
                        let start_index = output_count - distance as usize;
                        for cursor in 0..length as usize {
                            let literal = &output[start_index + cursor];
                            adler_checksum_a += *literal as u64;
                            if (std::u64::MAX - adler_checksum_b) > adler_checksum_a {
                                adler_checksum_b += adler_checksum_a;
                            } else {
                                adler_checksum_a %= ADLER_MODULO;
                                adler_checksum_b %= ADLER_MODULO;
                                adler_checksum_b += adler_checksum_a as u64;
                            }
                            output.push(*literal);
                        }
                    } else {
                        panic!("[E] Illegal distance");
                    }
                    output_count += length as usize;
                }
            }
        }
    }

    adler_checksum_a %= ADLER_MODULO;
    adler_checksum_b %= ADLER_MODULO;

    datastream.skip_to_next_byte();
    if (datastream.read_n_bits_as_lsb_first_u16(16).expect("").to_be() != adler_checksum_b as u16) || (datastream.read_n_bits_as_lsb_first_u16(16).expect("").to_be() != adler_checksum_a as u16) {
        panic!("[E] Adler-32 checksum failed.");
    } else {
        println!("[I] Adler-32 checksum: OK");
    }

    if output.iter().all(|&c| c.is_ascii()) {
        for char in output {
            print!("{}", char as char);
        }
    } else {
        println!("[W] Detected non-ascii character in the output stream.");
        for char in output {
            print!("{}", char.escape_ascii());
        }
    }

    Ok(())
}